esphome:
  name: espprint
  platform: ESP32
  board: nodemcu-32s
  arduino_version: latest
  includes: !include include.yaml
  on_boot:
    - lambda: SD_MMC.begin();
    - delay: 4s
    - lambda: get_sender(id(gcode_sender))->reset();
    - lambda: get_sender(id(gcode_sender))->sendGCode("M155 S4");

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Printer Fallback Hotspot"
    password: !secret fallback_password

captive_portal:

# Enable logging
logger:
  baud_rate: 0
  level: INFO

# Enable Home Assistant API
api:
  services:
    - service: home
      then:
        - lambda: get_sdSender(id(gcode_sender))->sendGCode("G28");
    - service: send_gcode
      variables:
        gcode: string
      then:
        - lambda: get_sdSender(id(gcode_sender))->sendGCode(gcode);
    - service: print_file
      variables:
        file: string
      then:
        - lambda: get_sdSender(id(gcode_sender))->print(file);
    - service: cancle_print
      then:
        - lambda: get_sdSender(id(gcode_sender))->stop();

ota:

web_server_base:
  id: upload_server_base

uart:
  id: uart_bus
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: 115200

custom_component:
- id: gcode_sender
  lambda: |-
    auto sender = new SDGCodeSender(id(uart_bus), 4, SD_MMC);
    return {sender};
- id: gcode_reader
  lambda: |-
    auto reader = new GCodeReader(id(uart_bus), get_sdSender(id(gcode_sender)));
    return {reader};
- id: upload_server
  lambda: |-
    auto upload = new util::UploadServer(id(upload_server_base), get_sdSender(id(gcode_sender)));
    App.register_component(upload);
    return {upload};
- id: events
  lambda: |-
    auto sendEvents = new sensors::GCodeEvents("SEND", get_sdSender(id(gcode_sender)));
    auto receiveEvents = new sensors::GCodeEvents("RECV", get_sdSender(id(gcode_sender)));
    App.register_component(sendEvents);
    App.register_component(receiveEvents);
    get_sdSender(id(gcode_sender))->addSensor(sendEvents);
    get_reader(id(gcode_reader))->addSensor(receiveEvents);
    return {sendEvents, receiveEvents};


sensor:
- platform: custom
  lambda: |-
    auto temperature = new sensors::TemperatureSensor(2);
    get_reader(id(gcode_reader))->addSensor(temperature);
    return temperature->m_temperatures;
  sensors:
  - name: "Tool Current Temperature"
    unit_of_measurement: 째C
    accuracy_decimals: 2
  - name: "Tool Target Temperature"
    unit_of_measurement: 째C
    accuracy_decimals: 2
  - name: "Bed Current Temperature"
    unit_of_measurement: 째C
    accuracy_decimals: 2
  - name: "Bed Target Temperature"
    unit_of_measurement: 째C
    accuracy_decimals: 2
- platform: custom
  lambda: |-
    auto progress = new sensors::ProgressSensor();
    get_sdSender(id(gcode_sender))->addSensor(progress);
    return {&progress->m_printProgress, &progress->m_remainingTime};
  sensors:
  - name: "Print Progress"
    unit_of_measurement: "%"
  - name: "Remaining Time"
    unit_of_measurement: "min"
- platform: uptime
  name: Uptime
- platform: custom
  lambda: |-
    auto memory = new sensors::MemorySensor();
    App.register_component(memory);
    return {memory};
  sensors:
  - name: "ESP Free Memory"
    unit_of_measurement: "bytes"
- platform: custom
  lambda: |-
    auto resend = new sensors::ResendSensor(get_sdSender(id(gcode_sender)));
    App.register_component(resend);
    return {resend};
  sensors:
  - name: "Print Resends"
    unit_of_measurement: "number"
- platform: custom
  lambda: |-
    auto timeouts = new sensors::TimeoutSensor(get_sdSender(id(gcode_sender)));
    App.register_component(timeouts);
    return {timeouts};
  sensors:
  - name: "Print Timeouts"
    unit_of_measurement: "number"
- platform: custom
  lambda: |-
    auto planner = new sensors::PlannerBufferSensor(get_sdSender(id(gcode_sender)));
    App.register_component(planner);
    return {planner};
  sensors:
  - name: "Printer Planner Buffer"
    unit_of_measurement: "number"
- platform: custom
  lambda: |-
    auto gcode = new sensors::GCodeBufferSensor(get_sdSender(id(gcode_sender)));
    App.register_component(gcode);
    return {gcode};
  sensors:
  - name: "Printer GCode Buffer"
    unit_of_measurement: "number"


text_sensor:
- platform: custom
  lambda: |-
    auto action = new sensors::ActionSensor();
    get_reader(id(gcode_reader))->addSensor(action);
    return {action};
  text_sensors:
  - name: "Last Action"
- platform: custom
  lambda: |-
    auto file = new sensors::FileSensor(get_sdSender(id(gcode_sender)));
    App.register_component(file);
    return {file};
  text_sensors:
  - name: "Current File"

<<: !include camera.yaml